#!/usr/bin/env bash
set -Eeuo pipefail

# =========================
#  Simple Gre - GRE Manager
#  Repo: https://github.com/ach1992/simple-gre
# =========================
# Debian/Ubuntu friendly (systemd)
# Features:
# - Create/Edit/Status/Info/Delete GRE tunnel
# - Defaults on Enter for most prompts
# - Auto-generates a PAIR CODE (10.X.Y) for tunnel /30 addressing
# - COPY BLOCK output to paste on the other server
#   -> Finish paste by pressing Enter TWICE on empty lines
# - Fixes rp_filter automatically (common GRE ping issue)
#   -> Applies immediately + persists with sysctl.d
# - Persists with systemd service
#
# Notes:
# - GRE requires IP protocol 47 allowed between public IPs.

APP_DIR="/etc/simple-gre"
CONF_FILE="$APP_DIR/gre.conf"
SYSCTL_FILE="$APP_DIR/99-simple-gre.conf"
SERVICE_FILE="/etc/systemd/system/simple-gre.service"
TUN_NAME_DEFAULT="gre1"

# Colors
RED="\033[0;31m"; GRN="\033[0;32m"; YEL="\033[0;33m"; BLU="\033[0;34m"
MAG="\033[0;35m"; CYA="\033[0;36m"; WHT="\033[1;37m"; NC="\033[0m"

REPO_URL="https://github.com/ach1992/simple-gre"
APP_NAME="Simple Gre"

log()   { echo -e "${BLU}[INFO]${NC} $*"; }
ok()    { echo -e "${GRN}[OK]${NC} $*"; }
warn()  { echo -e "${YEL}[WARN]${NC} $*"; }
err()   { echo -e "${RED}[ERROR]${NC} $*"; }
pause() { read -r -p "Press Enter to continue..." _; }

require_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    err "This script must be run as root."
    exit 1
  fi
}

have_cmd() { command -v "$1" >/dev/null 2>&1; }

require_cmds() {
  local missing=()
  for c in ip awk sed grep sysctl systemctl ping; do
    have_cmd "$c" || missing+=("$c")
  done
  if ((${#missing[@]})); then
    err "Missing required commands: ${missing[*]}"
    err "On Debian/Ubuntu install: apt-get update && apt-get install -y iproute2 iputils-ping"
    exit 1
  fi
}

is_ipv4() {
  local ip="$1"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  local IFS=.
  read -r a b c d <<<"$ip"
  for o in "$a" "$b" "$c" "$d"; do
    [[ "$o" =~ ^[0-9]+$ ]] || return 1
    (( o >= 0 && o <= 255 )) || return 1
  done
  return 0
}

is_ifname() {
  local n="$1"
  [[ "$n" =~ ^[a-zA-Z0-9_.-]{1,15}$ ]] || return 1
  return 0
}

default_iface() {
  ip route 2>/dev/null | awk '/^default/{print $5; exit}'
}

get_iface_ip() {
  local iface="$1"
  ip -4 -o addr show dev "$iface" 2>/dev/null | awk '{print $4}' | head -n1 | cut -d/ -f1
}

read_existing_conf() {
  if [[ -f "$CONF_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONF_FILE"
    return 0
  fi
  return 1
}

write_conf() {
  mkdir -p "$APP_DIR"
  cat >"$CONF_FILE" <<EOF
# Generated by simple-gre
ROLE="${ROLE}"
PAIR_CODE="${PAIR_CODE}"
TUN_NAME="${TUN_NAME}"
LOCAL_WAN_IP="${LOCAL_WAN_IP}"
REMOTE_WAN_IP="${REMOTE_WAN_IP}"
TUN_LOCAL_CIDR="${TUN_LOCAL_CIDR}"
TUN_REMOTE_IP="${TUN_REMOTE_IP}"
MTU="${MTU}"
TTL="${TTL}"
ENABLE_FORWARDING="${ENABLE_FORWARDING}"
DISABLE_RPFILTER="${DISABLE_RPFILTER}"
EOF
  chmod 600 "$CONF_FILE"
}

# Persist sysctl fixes (especially rp_filter for the tunnel IF)
write_sysctl_persist() {
  mkdir -p "$APP_DIR"
  cat >"$SYSCTL_FILE" <<EOF
# Simple Gre sysctl (persist)
net.ipv4.ip_forward=$( [[ "${ENABLE_FORWARDING}" == "yes" ]] && echo 1 || echo 0 )
# rp_filter off (recommended for GRE)
net.ipv4.conf.all.rp_filter=0
net.ipv4.conf.default.rp_filter=0
net.ipv4.conf.${TUN_NAME}.rp_filter=0
EOF
  chmod 644 "$SYSCTL_FILE"
  # make it active now
  sysctl --system >/dev/null 2>&1 || true
}

create_systemd_service() {
  cat >"$SERVICE_FILE" <<'EOF'
[Unit]
Description=Simple Gre - GRE Tunnel
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/sbin/simple-gre-up
ExecStop=/usr/local/sbin/simple-gre-down

[Install]
WantedBy=multi-user.target
EOF

  # Up script
  cat >/usr/local/sbin/simple-gre-up <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP_DIR="/etc/simple-gre"
CONF_FILE="$APP_DIR/gre.conf"
SYSCTL_FILE="$APP_DIR/99-simple-gre.conf"
[[ -f "$CONF_FILE" ]] || { echo "Config not found: $CONF_FILE" >&2; exit 1; }
# shellcheck disable=SC1090
source "$CONF_FILE"

apply_sysctl() {
  # Apply persistent sysctl first if present
  if [[ -f "$SYSCTL_FILE" ]]; then
    sysctl --system >/dev/null 2>&1 || true
  fi

  if [[ "${ENABLE_FORWARDING}" == "yes" ]]; then
    sysctl -w net.ipv4.ip_forward=1 >/dev/null || true
  fi

  if [[ "${DISABLE_RPFILTER}" == "yes" ]]; then
    sysctl -w net.ipv4.conf.all.rp_filter=0 >/dev/null || true
    sysctl -w net.ipv4.conf.default.rp_filter=0 >/dev/null || true
  fi
}

enforce_iface_rpfilter() {
  # IMPORTANT: Some providers reset rp_filter on newly-created interfaces.
  # Enforce AFTER creating & bringing the interface UP.
  if [[ "${DISABLE_RPFILTER}" == "yes" ]]; then
    sysctl -w "net.ipv4.conf.${TUN_NAME}.rp_filter=0" >/dev/null 2>&1 || true
  fi
}

create_tunnel() {
  # If exists, ensure it's up + settings, then return
  if ip link show "${TUN_NAME}" >/dev/null 2>&1; then
    ip link set "${TUN_NAME}" mtu "${MTU}" >/dev/null 2>&1 || true
    ip link set "${TUN_NAME}" up >/dev/null 2>&1 || true
    enforce_iface_rpfilter
    exit 0
  fi

  ip tunnel add "${TUN_NAME}" mode gre local "${LOCAL_WAN_IP}" remote "${REMOTE_WAN_IP}" ttl "${TTL}"
  ip link set "${TUN_NAME}" mtu "${MTU}"
  ip addr add "${TUN_LOCAL_CIDR}" dev "${TUN_NAME}"
  ip link set "${TUN_NAME}" up

  enforce_iface_rpfilter
}

apply_sysctl
create_tunnel
EOF

  # Down script
  cat >/usr/local/sbin/simple-gre-down <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP_DIR="/etc/simple-gre"
CONF_FILE="$APP_DIR/gre.conf"
[[ -f "$CONF_FILE" ]] || exit 0
# shellcheck disable=SC1090
source "$CONF_FILE"

ip link set "${TUN_NAME}" down >/dev/null 2>&1 || true
ip tunnel del "${TUN_NAME}" >/dev/null 2>&1 || true
EOF

  chmod +x /usr/local/sbin/simple-gre-up /usr/local/sbin/simple-gre-down
  systemctl daemon-reload
  systemctl enable simple-gre.service >/dev/null
}

apply_now() {
  systemctl restart simple-gre.service
}

remove_service_and_scripts() {
  systemctl stop simple-gre.service >/dev/null 2>&1 || true
  systemctl disable simple-gre.service >/dev/null 2>&1 || true
  rm -f "$SERVICE_FILE"
  rm -f /usr/local/sbin/simple-gre-up /usr/local/sbin/simple-gre-down
  systemctl daemon-reload
}

# -------------------------
# PAIR CODE + COPY BLOCK
# -------------------------
generate_pair_code() {
  local rx ry
  rx=$(( (RANDOM % 254) + 1 ))
  ry=$(( (RANDOM % 254) + 1 ))
  echo "10.${rx}.${ry}"
}

parse_pair_code() {
  local pc="$1"
  if [[ ! "$pc" =~ ^10\.([0-9]{1,3})\.([0-9]{1,3})$ ]]; then
    return 1
  fi
  local x="${BASH_REMATCH[1]}" y="${BASH_REMATCH[2]}"
  [[ "$x" =~ ^[0-9]+$ && "$y" =~ ^[0-9]+$ ]] || return 1
  (( x >= 0 && x <= 255 && y >= 0 && y <= 255 )) || return 1
  echo "$x $y"
}

recompute_tunnel_ips_from_pair() {
  local parsed rx ry
  parsed="$(parse_pair_code "${PAIR_CODE}")" || { err "PAIR_CODE is invalid."; return 1; }
  rx="${parsed% *}"; ry="${parsed#* }"

  if [[ "${ROLE}" == "source" ]]; then
    TUN_LOCAL_CIDR="10.${rx}.${ry}.1/30"
    TUN_REMOTE_IP="10.${rx}.${ry}.2"
  else
    TUN_LOCAL_CIDR="10.${rx}.${ry}.2/30"
    TUN_REMOTE_IP="10.${rx}.${ry}.1"
  fi
  return 0
}

print_copy_block() {
  local src_ip dst_ip
  if [[ "${ROLE}" == "source" ]]; then
    src_ip="${LOCAL_WAN_IP}"
    dst_ip="${REMOTE_WAN_IP}"
  else
    src_ip="${REMOTE_WAN_IP}"
    dst_ip="${LOCAL_WAN_IP}"
  fi

  echo "----- SIMPLE_GRE_COPY_BLOCK -----"
  echo "PAIR_CODE=${PAIR_CODE}"
  echo "SOURCE_PUBLIC_IP=${src_ip}"
  echo "DEST_PUBLIC_IP=${dst_ip}"
  echo "TUN_NAME=${TUN_NAME}"
  echo "MTU=${MTU}"
  echo "TTL=${TTL}"
  echo "ENABLE_FORWARDING=${ENABLE_FORWARDING}"
  echo "DISABLE_RPFILTER=${DISABLE_RPFILTER}"
  echo "----- END_COPY_BLOCK -----"
}

# Double-Enter paste input:
# - User pastes block
# - Then presses Enter TWICE on empty lines to finish
# - If user presses only once, show a clear hint (no "stuck" feeling)
prompt_paste_copy_block() {
  echo -e "${CYA}Optional:${NC} Paste COPY BLOCK now (press Enter to skip)."
  echo -e "Finish paste by pressing ${WHT}Enter TWICE${NC} on empty lines."
  echo -e "${YEL}Example:${NC} Paste the block, then press Enter, then press Enter again."
  echo

  local first=""
  read -r -p "Paste first line (or just Enter to skip): " first || true
  if [[ -z "${first:-}" ]]; then
    return 0
  fi

  local lines=()
  lines+=("$first")

  local empty_count=0
  while true; do
    local line=""
    read -r line || true

    if [[ -z "${line:-}" ]]; then
      empty_count=$((empty_count + 1))
      if (( empty_count == 1 )); then
        echo -e "${YEL}Almost done:${NC} press Enter one more time to finish paste."
      fi
      if (( empty_count >= 2 )); then
        break
      fi
      continue
    fi

    empty_count=0
    lines+=("$line")
  done

  # Parse key=value
  local kv key val
  for kv in "${lines[@]}"; do
    [[ "$kv" =~ ^[A-Z0-9_]+= ]] || continue
    key="${kv%%=*}"
    val="${kv#*=}"
    case "$key" in
      PAIR_CODE) PAIR_CODE="$val" ;;
      SOURCE_PUBLIC_IP) PASTE_SOURCE_PUBLIC_IP="$val" ;;
      DEST_PUBLIC_IP)   PASTE_DEST_PUBLIC_IP="$val" ;;
      TUN_NAME) TUN_NAME="$val" ;;
      MTU) MTU="$val" ;;
      TTL) TTL="$val" ;;
      ENABLE_FORWARDING) ENABLE_FORWARDING="$val" ;;
      DISABLE_RPFILTER)  DISABLE_RPFILTER="$val" ;;
      *) : ;;
    esac
  done

  # Validate pasted fields
  if [[ -n "${PAIR_CODE:-}" ]] && ! parse_pair_code "$PAIR_CODE" >/dev/null; then
    err "Pasted PAIR_CODE is invalid."
    return 1
  fi
  if [[ -n "${PASTE_SOURCE_PUBLIC_IP:-}" ]] && ! is_ipv4 "$PASTE_SOURCE_PUBLIC_IP"; then
    err "Pasted SOURCE_PUBLIC_IP is invalid."
    return 1
  fi
  if [[ -n "${PASTE_DEST_PUBLIC_IP:-}" ]] && ! is_ipv4 "$PASTE_DEST_PUBLIC_IP"; then
    err "Pasted DEST_PUBLIC_IP is invalid."
    return 1
  fi
  if [[ -n "${TUN_NAME:-}" ]] && ! is_ifname "$TUN_NAME"; then
    err "Pasted TUN_NAME is invalid."
    return 1
  fi
  if [[ -n "${MTU:-}" ]]; then
    [[ "$MTU" =~ ^[0-9]+$ ]] || { err "Pasted MTU must be numeric."; return 1; }
    (( MTU >= 1200 && MTU <= 9000 )) || { err "Pasted MTU out of range."; return 1; }
  fi
  if [[ -n "${TTL:-}" ]]; then
    [[ "$TTL" =~ ^[0-9]+$ ]] || { err "Pasted TTL must be numeric."; return 1; }
    (( TTL >= 1 && TTL <= 255 )) || { err "Pasted TTL out of range."; return 1; }
  fi
  if [[ -n "${ENABLE_FORWARDING:-}" ]] && [[ "$ENABLE_FORWARDING" != "yes" && "$ENABLE_FORWARDING" != "no" ]]; then
    err "Pasted ENABLE_FORWARDING must be 'yes' or 'no'."
    return 1
  fi
  if [[ -n "${DISABLE_RPFILTER:-}" ]] && [[ "$DISABLE_RPFILTER" != "yes" && "$DISABLE_RPFILTER" != "no" ]]; then
    err "Pasted DISABLE_RPFILTER must be 'yes' or 'no'."
    return 1
  fi

  ok "COPY BLOCK parsed successfully."
  return 0
}

# ---------------
# Prompts
# ---------------
prompt_role() {
  echo "Select server role:"
  echo "  1) Source (Iran)"
  echo "  2) Destination (Abroad)"
  local choice
  while true; do
    read -r -p "Enter choice [1-2]: " choice || true
    case "${choice:-}" in
      1) ROLE="source"; break ;;
      2) ROLE="destination"; break ;;
      *) err "Invalid choice. Please enter 1 or 2." ;;
    esac
  done
}

prompt_tun_name_keep() {
  local inp
  read -r -p "Tunnel interface name [${TUN_NAME}]: " inp || true
  inp="${inp:-$TUN_NAME}"
  is_ifname "$inp" || { err "Invalid interface name."; return 1; }
  TUN_NAME="$inp"
  return 0
}

prompt_local_wan_ip_keep() {
  local inp def_if def_ip
  def_if="$(default_iface || true)"
  def_ip=""
  if [[ -n "${def_if:-}" ]]; then
    def_ip="$(get_iface_ip "$def_if" || true)"
  fi

  if [[ -n "${LOCAL_WAN_IP:-}" ]]; then
    read -r -p "Local public IPv4 [${LOCAL_WAN_IP}]: " inp || true
    inp="${inp:-$LOCAL_WAN_IP}"
  elif [[ -n "${def_ip:-}" ]]; then
    read -r -p "Local public IPv4 (detected: ${def_ip}) [${def_ip}]: " inp || true
    inp="${inp:-$def_ip}"
  else
    read -r -p "Local public IPv4: " inp || true
  fi

  is_ipv4 "${inp:-}" || { err "Invalid IPv4 address."; return 1; }
  LOCAL_WAN_IP="$inp"
  return 0
}

prompt_remote_wan_ip_keep() {
  local inp
  read -r -p "Remote public IPv4 [${REMOTE_WAN_IP:-}]: " inp || true
  inp="${inp:-${REMOTE_WAN_IP:-}}"
  is_ipv4 "${inp:-}" || { err "Invalid IPv4 address."; return 1; }
  REMOTE_WAN_IP="$inp"
  return 0
}

prompt_pair_code_keep() {
  local inp
  if [[ -z "${PAIR_CODE:-}" ]]; then
    echo "PAIR CODE format: 10.X.Y"
    read -r -p "PAIR CODE [auto]: " inp || true
    if [[ -z "${inp:-}" ]]; then
      PAIR_CODE="$(generate_pair_code)"
      ok "Generated PAIR CODE: ${PAIR_CODE}"
      return 0
    fi
    parse_pair_code "$inp" >/dev/null || { err "Invalid PAIR CODE."; return 1; }
    PAIR_CODE="$inp"
    return 0
  fi

  read -r -p "PAIR CODE [${PAIR_CODE}] (Enter=keep): " inp || true
  inp="${inp:-$PAIR_CODE}"
  parse_pair_code "$inp" >/dev/null || { err "Invalid PAIR CODE."; return 1; }
  PAIR_CODE="$inp"
  return 0
}

prompt_numbers_keep() {
  local inp
  read -r -p "MTU [${MTU}]: " inp || true
  inp="${inp:-$MTU}"
  [[ "$inp" =~ ^[0-9]+$ ]] && (( inp >= 1200 && inp <= 9000 )) || { err "Invalid MTU."; return 1; }
  MTU="$inp"

  read -r -p "TTL [${TTL}]: " inp || true
  inp="${inp:-$TTL}"
  [[ "$inp" =~ ^[0-9]+$ ]] && (( inp >= 1 && inp <= 255 )) || { err "Invalid TTL."; return 1; }
  TTL="$inp"
  return 0
}

prompt_tuning_keep() {
  local inp
  read -r -p "Enable IPv4 forwarding? [${ENABLE_FORWARDING}] (yes/no): " inp || true
  inp="${inp:-$ENABLE_FORWARDING}"
  [[ "$inp" == "yes" || "$inp" == "no" ]] || { err "Invalid value for forwarding."; return 1; }
  ENABLE_FORWARDING="$inp"

  read -r -p "Disable rp_filter? [${DISABLE_RPFILTER}] (yes/no): " inp || true
  inp="${inp:-$DISABLE_RPFILTER}"
  [[ "$inp" == "yes" || "$inp" == "no" ]] || { err "Invalid value for rp_filter."; return 1; }
  DISABLE_RPFILTER="$inp"
  return 0
}

# ---------------
# Actions
# ---------------
show_info() {
  if ! read_existing_conf; then
    err "No existing configuration found at: $CONF_FILE"
    return
  fi

  echo -e "${MAG}===== Current GRE Configuration =====${NC}"
  echo "Role:                ${ROLE:-N/A}"
  echo "Pair code:           ${PAIR_CODE:-N/A}"
  echo "Tunnel name:         ${TUN_NAME:-N/A}"
  echo "Local public IP:     ${LOCAL_WAN_IP:-N/A}"
  echo "Remote public IP:    ${REMOTE_WAN_IP:-N/A}"
  echo "Local tunnel CIDR:   ${TUN_LOCAL_CIDR:-N/A}"
  echo "Remote tunnel IP:    ${TUN_REMOTE_IP:-N/A}"
  echo "MTU:                 ${MTU:-N/A}"
  echo "TTL:                 ${TTL:-N/A}"
  echo "IPv4 forwarding:     ${ENABLE_FORWARDING:-N/A}"
  echo "rp_filter disabled:  ${DISABLE_RPFILTER:-N/A}"
  echo "Config file:         ${CONF_FILE}"
  echo "Sysctl file:         ${SYSCTL_FILE}"
  echo "Service:             simple-gre.service"
  echo

  echo -e "${CYA}COPY BLOCK (paste on the other server):${NC}"
  print_copy_block
  echo -e "${YEL}Finish paste on the other server:${NC} Press Enter twice on empty lines."
}

do_create() {
  log "Creating GRE tunnel configuration..."
  echo

  prompt_role
  echo

  # Defaults
  TUN_NAME="${TUN_NAME_DEFAULT}"
  MTU="1476"
  TTL="255"
  ENABLE_FORWARDING="yes"
  DISABLE_RPFILTER="yes"
  PAIR_CODE=""
  LOCAL_WAN_IP=""
  REMOTE_WAN_IP=""
  PASTE_SOURCE_PUBLIC_IP=""
  PASTE_DEST_PUBLIC_IP=""

  # Optional paste (double-enter finish)
  if ! prompt_paste_copy_block; then
    err "Failed to parse COPY BLOCK."
    return
  fi
  echo

  # If pasted public IPs, swap based on role
  if [[ -n "${PASTE_SOURCE_PUBLIC_IP:-}" && -n "${PASTE_DEST_PUBLIC_IP:-}" ]]; then
    if [[ "${ROLE}" == "source" ]]; then
      LOCAL_WAN_IP="${PASTE_SOURCE_PUBLIC_IP}"
      REMOTE_WAN_IP="${PASTE_DEST_PUBLIC_IP}"
    else
      LOCAL_WAN_IP="${PASTE_DEST_PUBLIC_IP}"
      REMOTE_WAN_IP="${PASTE_SOURCE_PUBLIC_IP}"
    fi
    ok "Public IPs filled from COPY BLOCK."
  fi

  prompt_tun_name_keep || return
  prompt_local_wan_ip_keep || return
  prompt_remote_wan_ip_keep || return
  prompt_pair_code_keep || return

  recompute_tunnel_ips_from_pair || return

  prompt_numbers_keep || return
  prompt_tuning_keep || return

  if ip link show "$TUN_NAME" >/dev/null 2>&1; then
    err "Interface '$TUN_NAME' already exists. Choose a different name or delete existing tunnel."
    return
  fi

  write_conf
  write_sysctl_persist
  create_systemd_service
  apply_now

  ok "Tunnel created and persisted (systemd)."
  echo
  echo -e "${GRN}Tunnel addressing:${NC}"
  echo "  PAIR CODE:          ${PAIR_CODE}"
  echo "  Local tunnel CIDR:  ${TUN_LOCAL_CIDR}"
  echo "  Remote tunnel IP:   ${TUN_REMOTE_IP}"
  echo
  echo -e "${CYA}COPY BLOCK (paste on the other server):${NC}"
  print_copy_block
  echo -e "${YEL}Finish paste on the other server:${NC} Press Enter twice on empty lines."
}

do_edit() {
  if ! read_existing_conf; then
    err "No existing configuration found. Use 'Create' first."
    return
  fi

  log "Editing existing configuration."
  warn "Press Enter to keep current values."
  echo

  local r inp

  echo "Current role: ${ROLE}"
  read -r -p "Change role? (1=Source/Iran, 2=Destination/Abroad, Enter=keep): " r || true
  if [[ -n "${r:-}" ]]; then
    case "$r" in
      1) ROLE="source" ;;
      2) ROLE="destination" ;;
      *) err "Invalid choice. Keeping existing role." ;;
    esac
  fi

  read -r -p "PAIR CODE [${PAIR_CODE:-N/A}] (Enter=keep, empty auto-generate): " inp || true
  if [[ -n "${inp:-}" ]]; then
    if parse_pair_code "$inp" >/dev/null; then
      PAIR_CODE="$inp"
    else
      err "Invalid PAIR CODE. Keeping existing."
    fi
  fi
  if [[ -z "${PAIR_CODE:-}" ]]; then
    PAIR_CODE="$(generate_pair_code)"
    ok "Generated PAIR CODE: ${PAIR_CODE}"
  fi
  recompute_tunnel_ips_from_pair || return

  prompt_tun_name_keep || return
  prompt_local_wan_ip_keep || return
  prompt_remote_wan_ip_keep || return
  prompt_numbers_keep || return
  prompt_tuning_keep || return

  write_conf
  write_sysctl_persist
  systemctl daemon-reload
  apply_now
  ok "Configuration updated and applied."
  echo
  echo -e "${CYA}COPY BLOCK (paste on the other server):${NC}"
  print_copy_block
  echo -e "${YEL}Finish paste on the other server:${NC} Press Enter twice on empty lines."
}

do_status() {
  if ! read_existing_conf; then
    err "No existing configuration found. Use 'Create' first."
    return
  fi

  echo -e "${MAG}===== GRE Status =====${NC}"
  echo -e "${WHT}Service:${NC}"
  systemctl --no-pager --full status simple-gre.service || true
  echo

  echo -e "${WHT}Interface:${NC}"
  if ! ip -d link show "$TUN_NAME" >/dev/null 2>&1; then
    err "Tunnel interface not found. Try: Create or restart service."
    return
  fi
  ip -d link show "$TUN_NAME" || true
  echo

  echo -e "${WHT}IP addresses:${NC}"
  ip -4 addr show dev "$TUN_NAME" || true
  echo

  echo -e "${WHT}rp_filter (common GRE issue):${NC}"
  sysctl "net.ipv4.conf.${TUN_NAME}.rp_filter" 2>/dev/null || true
  echo

  echo -e "${WHT}Counters (traffic flow indicator):${NC}"
  ip -s link show "$TUN_NAME" || true
  echo

  echo -e "${WHT}Connectivity test:${NC} ping remote tunnel IP (${TUN_REMOTE_IP})"
  if ping -c 3 -W 2 "$TUN_REMOTE_IP" >/dev/null 2>&1; then
    ok "Ping successful. Tunnel looks UP and reachable."
  else
    warn "Ping failed."
    warn "If GRE packets arrive but ping fails, check rp_filter:"
    warn "  sysctl net.ipv4.conf.${TUN_NAME}.rp_filter  (should be 0)"
    warn "This script persists rp_filter=0, but some providers override it."
  fi
}

do_delete() {
  if [[ -f "$CONF_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONF_FILE"
    warn "This will remove the GRE tunnel, systemd service, sysctl file, and config."
    local yn
    read -r -p "Are you sure? [y/N]: " yn || true
    yn="${yn:-N}"
    if [[ ! "$yn" =~ ^([yY])$ ]]; then
      log "Canceled."
      return
    fi

    remove_service_and_scripts
    rm -f "$CONF_FILE" "$SYSCTL_FILE"
    rmdir "$APP_DIR" >/dev/null 2>&1 || true

    ip link set "${TUN_NAME}" down >/dev/null 2>&1 || true
    ip tunnel del "${TUN_NAME}" >/dev/null 2>&1 || true

    ok "Deleted."
  else
    err "No configuration found to delete."
  fi
}

banner() {
  echo -e "${MAG}========================================${NC}"
  echo -e "${WHT}  ${APP_NAME}${NC}  ${CYA}(GRE Tunnel Manager)${NC}"
  echo -e "${YEL}  Repo:${NC} ${BLU}${REPO_URL}${NC}"
  echo -e "${MAG}========================================${NC}"
}

menu() {
  while true; do
    clear || true
    banner
    echo -e "${CYA}1)${NC} Create tunnel"
    echo -e "${CYA}2)${NC} Edit tunnel"
    echo -e "${CYA}3)${NC} Status"
    echo -e "${CYA}4)${NC} Info (includes COPY BLOCK)"
    echo -e "${CYA}5)${NC} Delete"
    echo -e "${CYA}0)${NC} Exit"
    echo -e "${MAG}----------------------------------------${NC}"
    local choice
    read -r -p "Select an option [0-5]: " choice || true
    case "${choice:-}" in
      1) do_create; pause ;;
      2) do_edit; pause ;;
      3) do_status; pause ;;
      4) show_info; pause ;;
      5) do_delete; pause ;;
      0) exit 0 ;;
      *) err "Invalid selection."; pause ;;
    esac
  done
}

main() {
  require_root
  require_cmds
  menu
}

main "$@"
