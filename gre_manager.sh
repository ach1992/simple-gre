#!/usr/bin/env bash
set -Eeuo pipefail

# =========================
# GRE Tunnel Manager (Menu)
# =========================
# Features:
# - Create/Edit/Status/Info/Delete GRE tunnel
# - Validates inputs (IPv4/CIDR/Interface)
# - Applies "sane" sysctl tuning (forwarding, rp_filter)
# - Persists with systemd service
#
# Tested targets: Debian/Ubuntu/CentOS/RHEL (systemd required)

APP_DIR="/etc/gre-menu"
CONF_FILE="$APP_DIR/gre.conf"
SERVICE_FILE="/etc/systemd/system/gre-tunnel.service"
TUN_NAME_DEFAULT="gre1"

RED="\033[0;31m"; GRN="\033[0;32m"; YEL="\033[0;33m"; BLU="\033[0;34m"; NC="\033[0m"

log()   { echo -e "${BLU}[INFO]${NC} $*"; }
ok()    { echo -e "${GRN}[OK]${NC} $*"; }
warn()  { echo -e "${YEL}[WARN]${NC} $*"; }
err()   { echo -e "${RED}[ERROR]${NC} $*"; }
pause() { read -r -p "Press Enter to continue..." _; }

require_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    err "This script must be run as root."
    exit 1
  fi
}

have_cmd() { command -v "$1" >/dev/null 2>&1; }

require_cmds() {
  local missing=()
  for c in ip awk sed grep sysctl systemctl; do
    have_cmd "$c" || missing+=("$c")
  done
  if ((${#missing[@]})); then
    err "Missing required commands: ${missing[*]}"
    err "Please install iproute2 / systemd and try again."
    exit 1
  fi
}

is_ipv4() {
  local ip="$1"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  local IFS=.
  read -r a b c d <<<"$ip"
  for o in "$a" "$b" "$c" "$d"; do
    [[ "$o" =~ ^[0-9]+$ ]] || return 1
    (( o >= 0 && o <= 255 )) || return 1
  done
  return 0
}

is_cidr() {
  local cidr="$1"
  [[ "$cidr" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]{1,2})$ ]] || return 1
  local ip="${cidr%/*}" pfx="${cidr#*/}"
  is_ipv4 "$ip" || return 1
  [[ "$pfx" =~ ^[0-9]+$ ]] || return 1
  (( pfx >= 0 && pfx <= 32 )) || return 1
  return 0
}

is_ifname() {
  local n="$1"
  [[ "$n" =~ ^[a-zA-Z0-9_.-]{1,15}$ ]] || return 1
  return 0
}

default_iface() {
  # Get default route interface
  ip route 2>/dev/null | awk '/^default/{print $5; exit}'
}

get_iface_ip() {
  local iface="$1"
  ip -4 -o addr show dev "$iface" 2>/dev/null | awk '{print $4}' | head -n1 | cut -d/ -f1
}

read_existing_conf() {
  if [[ -f "$CONF_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONF_FILE"
    return 0
  fi
  return 1
}

write_conf() {
  mkdir -p "$APP_DIR"
  cat >"$CONF_FILE" <<EOF
# Generated by gre_manager.sh
ROLE="${ROLE}"
TUN_NAME="${TUN_NAME}"
LOCAL_WAN_IP="${LOCAL_WAN_IP}"
REMOTE_WAN_IP="${REMOTE_WAN_IP}"
TUN_LOCAL_CIDR="${TUN_LOCAL_CIDR}"
TUN_REMOTE_IP="${TUN_REMOTE_IP}"
MTU="${MTU}"
TTL="${TTL}"
ENABLE_FORWARDING="${ENABLE_FORWARDING}"
DISABLE_RPFILTER="${DISABLE_RPFILTER}"
EOF
  chmod 600 "$CONF_FILE"
}

create_systemd_service() {
  cat >"$SERVICE_FILE" <<'EOF'
[Unit]
Description=GRE Tunnel (managed by gre_manager.sh)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/sbin/gre-tunnel-up
ExecStop=/usr/local/sbin/gre-tunnel-down

[Install]
WantedBy=multi-user.target
EOF

  cat >/usr/local/sbin/gre-tunnel-up <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP_DIR="/etc/gre-menu"
CONF_FILE="$APP_DIR/gre.conf"
[[ -f "$CONF_FILE" ]] || { echo "Config not found: $CONF_FILE" >&2; exit 1; }
# shellcheck disable=SC1090
source "$CONF_FILE"

apply_sysctl() {
  if [[ "${ENABLE_FORWARDING}" == "yes" ]]; then
    sysctl -w net.ipv4.ip_forward=1 >/dev/null
  fi
  if [[ "${DISABLE_RPFILTER}" == "yes" ]]; then
    # loose/off for tunnel friendliness
    sysctl -w net.ipv4.conf.all.rp_filter=0 >/dev/null
    sysctl -w net.ipv4.conf.default.rp_filter=0 >/dev/null
    # also for the tunnel interface later
  fi
}

create_tunnel() {
  # If exists, skip creation
  if ip link show "${TUN_NAME}" >/dev/null 2>&1; then
    exit 0
  fi

  ip tunnel add "${TUN_NAME}" mode gre local "${LOCAL_WAN_IP}" remote "${REMOTE_WAN_IP}" ttl "${TTL}"
  ip link set "${TUN_NAME}" mtu "${MTU}"
  ip addr add "${TUN_LOCAL_CIDR}" dev "${TUN_NAME}"
  ip link set "${TUN_NAME}" up

  if [[ "${DISABLE_RPFILTER}" == "yes" ]]; then
    sysctl -w "net.ipv4.conf.${TUN_NAME}.rp_filter=0" >/dev/null || true
  fi
}

apply_sysctl
create_tunnel
EOF

  cat >/usr/local/sbin/gre-tunnel-down <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
APP_DIR="/etc/gre-menu"
CONF_FILE="$APP_DIR/gre.conf"
[[ -f "$CONF_FILE" ]] || exit 0
# shellcheck disable=SC1090
source "$CONF_FILE"

ip link set "${TUN_NAME}" down >/dev/null 2>&1 || true
ip tunnel del "${TUN_NAME}" >/dev/null 2>&1 || true
EOF

  chmod +x /usr/local/sbin/gre-tunnel-up /usr/local/sbin/gre-tunnel-down

  systemctl daemon-reload
  systemctl enable gre-tunnel.service >/dev/null
}

apply_now() {
  systemctl restart gre-tunnel.service
}

remove_service_and_scripts() {
  systemctl stop gre-tunnel.service >/dev/null 2>&1 || true
  systemctl disable gre-tunnel.service >/dev/null 2>&1 || true
  rm -f "$SERVICE_FILE"
  rm -f /usr/local/sbin/gre-tunnel-up /usr/local/sbin/gre-tunnel-down
  systemctl daemon-reload
}

prompt_role() {
  echo "Select server role:"
  echo "  1) Source (Iran)"
  echo "  2) Destination (Abroad)"
  local choice
  while true; do
    read -r -p "Enter choice [1-2]: " choice
    case "$choice" in
      1) ROLE="source"; break ;;
      2) ROLE="destination"; break ;;
      *) err "Invalid choice. Please enter 1 or 2." ;;
    esac
  done
}

prompt_tun_name() {
  local n
  read -r -p "Tunnel interface name [${TUN_NAME_DEFAULT}]: " n || true
  n="${n:-$TUN_NAME_DEFAULT}"
  if ! is_ifname "$n"; then
    err "Invalid interface name. Allowed: 1-15 chars [a-zA-Z0-9_.-]"
    return 1
  fi
  TUN_NAME="$n"
}

prompt_local_wan_ip() {
  local def_if def_ip inp
  def_if="$(default_iface || true)"
  def_ip=""
  if [[ -n "${def_if:-}" ]]; then
    def_ip="$(get_iface_ip "$def_if" || true)"
  fi
  if [[ -n "${def_ip:-}" ]]; then
    read -r -p "Local public IPv4 (detected: ${def_ip}) [${def_ip}]: " inp || true
    inp="${inp:-$def_ip}"
  else
    read -r -p "Local public IPv4: " inp
  fi
  if ! is_ipv4 "$inp"; then
    err "Invalid IPv4 address."
    return 1
  fi
  LOCAL_WAN_IP="$inp"
}

prompt_remote_wan_ip() {
  local inp
  read -r -p "Remote public IPv4: " inp
  if ! is_ipv4 "$inp"; then
    err "Invalid IPv4 address."
    return 1
  fi
  REMOTE_WAN_IP="$inp"
}

prompt_tunnel_ips() {
  echo "Tunnel addressing:"
  echo "  - Recommended: use a /30 (2 usable IPs)."
  echo "  - Press Enter to auto-generate a private /30."

  # Generate a random 10.X.Y.0/30 (avoid 0 and 255)
  local rx ry base_net
  rx=$(( (RANDOM % 254) + 1 ))
  ry=$(( (RANDOM % 254) + 1 ))
  base_net="10.${rx}.${ry}.0/30"

  local def_local def_remote
  if [[ "${ROLE}" == "source" ]]; then
    def_local="10.${rx}.${ry}.1/30"
    def_remote="10.${rx}.${ry}.2"
  else
    def_local="10.${rx}.${ry}.2/30"
    def_remote="10.${rx}.${ry}.1"
  fi

  local local_cidr remote_ip

  read -r -p "Local tunnel IPv4/CIDR [${def_local}]: " local_cidr || true
  local_cidr="${local_cidr:-$def_local}"
  if ! is_cidr "$local_cidr"; then
    err "Invalid CIDR."
    return 1
  fi

  read -r -p "Remote tunnel IPv4 [${def_remote}]: " remote_ip || true
  remote_ip="${remote_ip:-$def_remote}"
  if ! is_ipv4 "$remote_ip"; then
    err "Invalid IPv4 address."
    return 1
  fi

  TUN_LOCAL_CIDR="$local_cidr"
  TUN_REMOTE_IP="$remote_ip"

  # Helpful note:
  echo "Note: Auto-generated /30 base network: ${base_net}"
}

prompt_mtu_ttl() {
  local mtu ttl
  read -r -p "MTU [1476]: " mtu || true
  mtu="${mtu:-1476}"
  [[ "$mtu" =~ ^[0-9]+$ ]] || { err "MTU must be a number."; return 1; }
  (( mtu >= 1200 && mtu <= 9000 )) || { err "MTU out of range (1200-9000)."; return 1; }

  read -r -p "TTL [255]: " ttl || true
  ttl="${ttl:-255}"
  [[ "$ttl" =~ ^[0-9]+$ ]] || { err "TTL must be a number."; return 1; }
  (( ttl >= 1 && ttl <= 255 )) || { err "TTL out of range (1-255)."; return 1; }

  MTU="$mtu"
  TTL="$ttl"
}

prompt_tuning() {
  local a b
  read -r -p "Enable IPv4 forwarding? (recommended) [Y/n]: " a || true
  a="${a:-Y}"
  if [[ "$a" =~ ^([nN])$ ]]; then ENABLE_FORWARDING="no"; else ENABLE_FORWARDING="yes"; fi

  read -r -p "Disable rp_filter (recommended for tunnels)? [Y/n]: " b || true
  b="${b:-Y}"
  if [[ "$b" =~ ^([nN])$ ]]; then DISABLE_RPFILTER="no"; else DISABLE_RPFILTER="yes"; fi
}

show_info() {
  if ! read_existing_conf; then
    err "No existing configuration found at: $CONF_FILE"
    return
  fi
  echo "===== Current GRE Configuration ====="
  echo "Role:                ${ROLE}"
  echo "Tunnel name:         ${TUN_NAME}"
  echo "Local public IP:     ${LOCAL_WAN_IP}"
  echo "Remote public IP:    ${REMOTE_WAN_IP}"
  echo "Local tunnel CIDR:   ${TUN_LOCAL_CIDR}"
  echo "Remote tunnel IP:    ${TUN_REMOTE_IP}"
  echo "MTU:                 ${MTU}"
  echo "TTL:                 ${TTL}"
  echo "IPv4 forwarding:     ${ENABLE_FORWARDING}"
  echo "rp_filter disabled:  ${DISABLE_RPFILTER}"
  echo "Config file:         ${CONF_FILE}"
  echo "Service:             gre-tunnel.service"
}

do_create() {
  log "Creating GRE tunnel configuration..."
  prompt_role
  prompt_tun_name || return
  prompt_local_wan_ip || return
  prompt_remote_wan_ip || return
  prompt_tunnel_ips || return
  prompt_mtu_ttl || return
  prompt_tuning

  # Basic sanity check: tunnel name conflict
  if ip link show "$TUN_NAME" >/dev/null 2>&1; then
    err "Interface '$TUN_NAME' already exists. Choose a different name or delete existing tunnel."
    return
  fi

  write_conf
  create_systemd_service
  apply_now

  ok "Tunnel created and persisted."
  ok "Use 'Status' to verify connectivity."
}

do_edit() {
  if ! read_existing_conf; then
    err "No existing configuration found. Use 'Create' first."
    return
  fi
  log "Editing existing configuration. Press Enter to keep current values."

  echo "Current role: $ROLE"
  local r
  read -r -p "Change role? (1=Source/Iran, 2=Destination/Abroad, Enter=keep): " r || true
  if [[ -n "${r:-}" ]]; then
    case "$r" in
      1) ROLE="source" ;;
      2) ROLE="destination" ;;
      *) err "Invalid choice. Keeping existing role." ;;
    esac
  fi

  local inp
  read -r -p "Tunnel interface name [${TUN_NAME}]: " inp || true
  inp="${inp:-$TUN_NAME}"
  if is_ifname "$inp"; then TUN_NAME="$inp"; else err "Invalid name. Keeping existing."; fi

  read -r -p "Local public IPv4 [${LOCAL_WAN_IP}]: " inp || true
  inp="${inp:-$LOCAL_WAN_IP}"
  if is_ipv4 "$inp"; then LOCAL_WAN_IP="$inp"; else err "Invalid IPv4. Keeping existing."; fi

  read -r -p "Remote public IPv4 [${REMOTE_WAN_IP}]: " inp || true
  inp="${inp:-$REMOTE_WAN_IP}"
  if is_ipv4 "$inp"; then REMOTE_WAN_IP="$inp"; else err "Invalid IPv4. Keeping existing."; fi

  read -r -p "Local tunnel IPv4/CIDR [${TUN_LOCAL_CIDR}]: " inp || true
  inp="${inp:-$TUN_LOCAL_CIDR}"
  if is_cidr "$inp"; then TUN_LOCAL_CIDR="$inp"; else err "Invalid CIDR. Keeping existing."; fi

  read -r -p "Remote tunnel IPv4 [${TUN_REMOTE_IP}]: " inp || true
  inp="${inp:-$TUN_REMOTE_IP}"
  if is_ipv4 "$inp"; then TUN_REMOTE_IP="$inp"; else err "Invalid IPv4. Keeping existing."; fi

  read -r -p "MTU [${MTU}]: " inp || true
  inp="${inp:-$MTU}"
  if [[ "$inp" =~ ^[0-9]+$ ]] && (( inp >= 1200 && inp <= 9000 )); then MTU="$inp"; else err "Invalid MTU. Keeping existing."; fi

  read -r -p "TTL [${TTL}]: " inp || true
  inp="${inp:-$TTL}"
  if [[ "$inp" =~ ^[0-9]+$ ]] && (( inp >= 1 && inp <= 255 )); then TTL="$inp"; else err "Invalid TTL. Keeping existing."; fi

  read -r -p "Enable IPv4 forwarding? [${ENABLE_FORWARDING}] (yes/no): " inp || true
  inp="${inp:-$ENABLE_FORWARDING}"
  if [[ "$inp" == "yes" || "$inp" == "no" ]]; then ENABLE_FORWARDING="$inp"; else err "Invalid. Keeping existing."; fi

  read -r -p "Disable rp_filter? [${DISABLE_RPFILTER}] (yes/no): " inp || true
  inp="${inp:-$DISABLE_RPFILTER}"
  if [[ "$inp" == "yes" || "$inp" == "no" ]]; then DISABLE_RPFILTER="$inp"; else err "Invalid. Keeping existing."; fi

  write_conf
  systemctl daemon-reload
  apply_now
  ok "Configuration updated and applied."
}

do_status() {
  if ! read_existing_conf; then
    err "No existing configuration found. Use 'Create' first."
    return
  fi

  echo "===== GRE Status ====="
  echo "Service state:"
  systemctl --no-pager --full status gre-tunnel.service || true
  echo

  echo "Interface:"
  ip -d link show "$TUN_NAME" || { err "Tunnel interface not found."; return; }
  echo

  echo "IP addresses:"
  ip -4 addr show dev "$TUN_NAME" || true
  echo

  echo "Routes relevant to tunnel interface:"
  ip route show dev "$TUN_NAME" || true
  echo

  echo "Basic connectivity test (ICMP ping to remote tunnel IP: $TUN_REMOTE_IP)"
  if ping -c 3 -W 2 "$TUN_REMOTE_IP" >/dev/null 2>&1; then
    ok "Ping successful."
  else
    warn "Ping failed. Check firewall/UDP? (GRE is IP protocol 47), routing, and that both sides are up."
  fi
}

do_delete() {
  if [[ -f "$CONF_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONF_FILE"
    warn "This will remove the tunnel, systemd service, and config."
    local yn
    read -r -p "Are you sure? [y/N]: " yn || true
    yn="${yn:-N}"
    if [[ ! "$yn" =~ ^([yY])$ ]]; then
      log "Canceled."
      return
    fi

    remove_service_and_scripts
    rm -f "$CONF_FILE"
    rmdir "$APP_DIR" >/dev/null 2>&1 || true

    # attempt to delete tunnel if still exists
    ip link set "${TUN_NAME}" down >/dev/null 2>&1 || true
    ip tunnel del "${TUN_NAME}" >/dev/null 2>&1 || true

    ok "Deleted."
  else
    err "No configuration found to delete."
  fi
}

menu() {
  while true; do
    clear || true
    echo "========================================"
    echo " GRE Tunnel Manager"
    echo "========================================"
    echo "1) Create tunnel"
    echo "2) Edit tunnel"
    echo "3) Status"
    echo "4) Info"
    echo "5) Delete"
    echo "0) Exit"
    echo "----------------------------------------"
    local choice
    read -r -p "Select an option [0-5]: " choice || true
    case "${choice:-}" in
      1) do_create; pause ;;
      2) do_edit; pause ;;
      3) do_status; pause ;;
      4) show_info; pause ;;
      5) do_delete; pause ;;
      0) exit 0 ;;
      *) err "Invalid selection."; pause ;;
    esac
  done
}

main() {
  require_root
  require_cmds
  menu
}

main "$@"
